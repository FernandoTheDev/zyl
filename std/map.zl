import std.arena
import std.libc.string : { strcmp, strlen }
import std.libc.io : { printf }

// node
struct Entry!(K, V) {
    K key;
    V value;
    Entry!(K, V)* next = null
}

struct HashMap!(K, V) {
    Entry!(K, V)** buckets = null
    Arena* arena = null
    int capacity = 0
    int count = 0

    void init(HashMap!(K, V)* self, Arena* arena, int capacity) {
        self.arena = arena
        self.capacity = capacity
        self.buckets = (Entry!(K, V)**) self.arena.calloc((sizeof Entry!(K, V)*) * capacity)
        self.count = 0
    }

    int hash(HashMap!(K, V)* self, K key) {
        long h = -2128831035L
        int len = strlen(key)
        for int i = 0; i < len; i++ {
            h = h ^ (long)key[i]
            h = h * 16777619L
        }
        int idx = h % self.capacity
        if idx < 0 { idx = idx * -1 }
        return idx
    }

    void put(HashMap!(K, V)* self, K key, V value) {
        if self.buckets == null { 
            printf("Erro: HashMap nao inicializado com Arena\n") 
            return;
        }

        int idx = self.hash(key)
        Entry!(K, V)* current = self.buckets[idx]

        while current != null {
            if strcmp(current.key, key) == 0 {
                current.value = value
                return;
            }
            current = current.next
        }

        Entry!(K, V)* new_entry = (Entry!(K, V)*) self.arena.alloc(sizeof Entry!(K, V))
        new_entry.key = key
        new_entry.value = value
        new_entry.next = self.buckets[idx]
        
        self.buckets[idx] = new_entry
        self.count++
    }

    V* get(HashMap!(K, V)* self, K key) {
        if self.buckets == null return null
        
        int idx = self.hash(key)
        Entry!(K, V)* current = self.buckets[idx]

        while current != null {
            if strcmp(current.key, key) == 0 {
                return &(current.value)
            }
            current = current.next
        }
        return null
    }
}
