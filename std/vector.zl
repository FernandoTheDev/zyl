import std.arena
import std.libc.mem : { memcpy }
import std.libc.io : { printf, exit }

struct Vector!(T) {
    T* data = null
    int length = 0
    int capacity = 0
    Arena* arena = null

    void init(Vector!(T)* self, Arena* arena, int initial_capacity) {
        self.arena = arena
        self.length = 0
        
        if initial_capacity < 4 { initial_capacity = 4 }
        self.capacity = initial_capacity

        self.data = (T*) self.arena.alloc((sizeof T) * self.capacity)
    }

    void push(Vector!(T)* self, T value) {
        if self.arena == null {
            printf("Erro: Vector nao inicializado com Arena!\n")
            exit(1)
        }

        if self.length >= self.capacity {
            int old_capacity = self.capacity
            int new_capacity = old_capacity * 2
            
            T* new_data = (T*) self.arena.alloc((sizeof T) * new_capacity)
            if new_data == null {
                printf("Erro: Arena sem memoria para crescer Vector\n")
                exit(1)
            }

            memcpy(new_data, self.data, (sizeof T) * old_capacity)

            self.data = new_data
            self.capacity = new_capacity
        }

        self.data[self.length] = value
        self.length++
    }

    T pop(Vector!(T)* self) {
        if self.length <= 0 {
            printf("Erro: Pop em vetor vazio!\n")
            exit(1)
        }

        self.length--
        return self.data[self.length]
    }

    T get(Vector!(T)* self, int index) {
        if index < 0 || index >= self.length {
            printf("Erro: Index out of bounds\n")
            exit(1)
        }
        return self.data[index]
    }

    T opIndex(Vector!(T)* self, int index) {
        return self.get(index)
    }

    bool empty(Vector!(T)* self) {
        return self.length == 0
    }

    void reset(Vector!(T)* self) {
        self.length = 0
    }
}

